---
title: "ECON 773: Assignment 1"
author: "The BLUE Team, Jeneta Ljutic (400138420), Tadhg Taylor-McGreal (400330297), Stella Till (400364649)"
date: "January 12th 2026"
format:
  typst: 
    toc: TRUE
---

{{< pagebreak >}}

# Preface

## Goal

The goals of this assignment are to:

-   make sure your `R`, `Positron` are set up properly
-   learn to install packages in `R`
-   learn to edit text in `quarto`
-   learn to load data in `R`
-   learn to use 5 `dplyr` verbs for basic computations with data in `R`
-   learn to create some visualizations using `ggplot`
-   learn to render an `.qmd` to `.pdf` (via Typst)

## Instructions

Before you start the assignment, make sure to install `R` and Positron. Positron comes with command-line tools for `quarto`, which in turn includes `typst`.

You will use `quarto` for generating your assignment output file. You begin with this script downloaded from A2L. Make sure that it is placed in the same folder as any data that came with it. Instructions for editing `quarto` are discussed in class, or see the [Quarto website](www.quarto.org).

To submit this assignment:

-   edit the `author` and `date` fields in the `YAML` (lines 1-9). Do not touch any other line in the YAML.
-   complete the questions
-   render to pdf
-   email to TA

Some additional instructions:

1.  leave all the text between `## Question` and `### Answer` unchanged and write your answers between `### Answer` and the next `## Question`
2.  for each question that involves `R` code, **do not only write R code**, but add at least one sentence before the code explaining what you are going to do, and at least one line after the R code interpreting the result
3.  check spelling before submissions
4.  once your assignment is complete:
    -   *Render* it to pdf
    -   inspect the resulting `.pdf`: would you want to grade it?
    -   submit
    
To render this document, click the *Render* button in the menu just above the top of this file. Alternatively, use the command palette. This step may fail until you install additional packages.

{{< pagebreak >}}

# Job corps

## Installing packages and loading data

This question will be demonstrated in class.

For this and the next few questions, we will use the data used in H3.1. To load the data, you first have to install the `R` package that accompanies the book. To install a package in `R`, which you need to do once for every `R` installation, run `install.packages(<PACKAGE_NAME>)` in your console. We will use data from the `causalweight` package. To install it, run:

```{r}
#| eval: false
install.packages("causalweight")
install.packages("causalweight", repos = "https://cloud.r-project.org")
```

The `#| eval: false` switch in the options of the above code chunk ensure that the code is not run whenever you render this `.qmd` file. Once per `R` session, and once in each `.qmd` file, you need to load the functionality of installed packages that you wish to use. You can do this by `library(<PACKAGE_NAME)`. In this case:

```{r}
library(causalweight)
```

After a `library` command, the functions and data sets in a given package are available to you. To load the `JC` data from the `causalweight` package:

```{r}
data(JC)
```

We will explore this data set using tools from the `tidyverse` library. If that collection of packages is not yet installed, run:

```{r}
#| eval: false
install.packages("tidyverse")
install.packages("gt")
```

Load all the functionality in the `tidyverse`:

```{r}
library(tidyverse)
library(gt)
```

We will discover how to use the `tidyverse` as we go. Have a look at [this vignette](https://cran.r-project.org/web/packages/tidyverse/vignettes/paper.html) for the ideas behind it, and at [the book R4DS](https://r4ds.hadley.nz/) for a fantastic introduction to how to use it. In this assignment, we will focus on using

-   `dplyr` for data manipulation, start your practice [in this R4DS chapter](https://r4ds.hadley.nz/data-transform)
-   `ggplot` for data visualization, see [Grammar for Graphics](https://ggplot2.tidyverse.org/).

We start by putting `JC` in `tibble` format, and by having a look at the top lines using `tinytable`.

```{r}
JC <- as_tibble(JC)
JC |>
    select(1:6) |>
    head() |>
    gt()
```

To bring up a description of the variables, ask:

```{r}
#| eval: false
?JC
```

Answer the following questions, using one `dplyr` verb each:


1.  using `arrange`, sort the observations by age (first) and years of education at assignment (second)

To answer this question we will use the dplyr `arrange` tool to sort the data as directed within the question.
```{r}
JC <- JC |>
  dplyr::arrange(age, educ)
```

2.  make a new, binarized, variable `educ_high` that equals `TRUE` if the years of education at assignment is 12 or greater, and `FALSE` otherwise. Use:
    -   `mutate`
    -   `ifelse`
    -   the pipe operator `|>` to pass `JC` to `mutate`
    -   `-> JC` to overwrite the original `tibble`
    
```{r}
JC |>
  dplyr::mutate(educ_high = ifelse(educ >= 12, TRUE, FALSE)) -> JC
```

3.  use `select` to keep only the 5 variables: `assignment`; the weekly earnings in fourth year after assignment; the variable indicating `female`; the education variable that you just created; the variable that indicates whether education is missing at assignment. Save the result in a new tibble called `JC_short`

```{r}
JC_short <- JC |>
  dplyr::select(age, assignment, earny4, female, educ, educmis)
```

4.  starting from `JC_short`, use `filter` to keep only the observations for which `assignment` equals 1 and save the results as `JC_short_TG`. Create an analogous `JC_short_CG`.

```{r}
JC_short_TG <- JC_short |>
  dplyr::filter(assignment == 1)

JC_short_CG <- JC_short |>
  dplyr::filter(assignment == 0)
```

This works and we checked by visually analyzing the data set. We invite you to confirm this by seeing the printout in the appendix. 

5.  compute the mean weekly earnings in fourth year in the `JC_short_TG` tibble, and compare it to the analogous mean in `JC_short_CG`.

```{r}
TG_mean <- JC_short_TG |>
  dplyr::summarise(mean_earny4 = mean(earny4, na.rm = TRUE))

CG_mean <- JC_short_CG |>
  dplyr::summarise(mean_earny4 = mean(earny4, na.rm = TRUE))

TG_mean
CG_mean
```

Interpret the final result, and compare it to the result on H, p. 21.

### Answer

```{r}
as.numeric(TG_mean$mean_earny4) - as.numeric(CG_mean$mean_earny4)
```
...

{{< pagebreak >}}

## Piping and `group_by`

This question will be demonstrated in class.

You will practice how to use a sequence of `pipes`, use `group_by`. You continue with the `JC_short` data that we created in the previous question.

First, use `group_by` to group the observations in `JC_short` by `female`, and comment on the result.

Second, pipe the result from `group_by` into a `summarize` command to see the means for each group in one table. Interpret the result.

Third, start with a `filter` command that keeps only those with education information available, then group by `assignment`, then compute the mean of `earny4` for each group. Interpret the result.

Fourth, repeat this, grouping by `female` **and** `assignment`. Interpret your result, discussing the conditional average treatment effect (CATE) for men and for women. Compare it to the unconditional ATE. Is the unconditional ATE an average of the two CATEs? Comment on this finding.

### Answer

```{r}
# 1) Group by female (create grouped object and also show counts)
grouped_by_female <- JC_short |> dplyr::group_by(female)
female_counts <- grouped_by_female |> dplyr::summarise(n = dplyr::n(), .groups = "drop")

means_by_female <- JC_short |>
  dplyr::group_by(female) |>
  dplyr::summarise(mean_earny4 = mean(earny4, na.rm = TRUE), n = dplyr::n(), .groups = "drop")

filtered <- JC_short |> dplyr::filter(!is.na(educ))
means_by_assignment_filtered <- filtered |>
  dplyr::group_by(assignment) |>
  dplyr::summarise(mean_earny4 = mean(earny4, na.rm = TRUE), n = dplyr::n(), .groups = "drop")

means_by_female_assignment <- filtered |>
  dplyr::group_by(female, assignment) |>
  dplyr::summarise(mean_earny4 = mean(earny4, na.rm = TRUE), n = dplyr::n(), .groups = "drop")

CATEs <- means_by_female_assignment |>
  tidyr::pivot_wider(names_from = assignment, values_from = mean_earny4, names_prefix = "assign_") |>
  dplyr::mutate(CATE = assign_1 - assign_0)

female_shares <- filtered |>
  dplyr::group_by(female) |>
  dplyr::summarise(share = dplyr::n() / nrow(filtered), .groups = "drop")

CATEs_with_shares <- CATEs |>
  dplyr::left_join(female_shares, by = "female") |>
  dplyr::mutate(weighted_CATE = CATE * share)

weighted_CATE_sum <- CATEs_with_shares |> dplyr::summarise(weighted_CATE = sum(weighted_CATE)) 

ATE_unconditional_filtered <- means_by_assignment_filtered |>
  tidyr::pivot_wider(names_from = assignment, values_from = mean_earny4, names_prefix = "assign_") |>
  dplyr::mutate(ATE = assign_1 - assign_0) 

list(
  female_counts = female_counts,
  means_by_female = means_by_female,
  means_by_assignment_filtered = means_by_assignment_filtered,
  means_by_female_assignment = means_by_female_assignment,
  CATEs = CATEs,
  female_shares = female_shares,
  CATEs_with_shares = CATEs_with_shares,
  weighted_CATE_sum = weighted_CATE_sum,
  ATE_unconditional_filtered = ATE_unconditional_filtered
)
```

...

{{< pagebreak >}}

## Weeks worked

You may be interested in the effect of the program on variables other than earnings. This question focuses on the proportion of weeks employed in fourth year after assignment.

First, modify the code in the previous question to answer this question using the `JC` data. This question is about the ATE, so do not split out by another variable. Interpret your findings.

Second, using `group_by` and `summarise` to split out results separately by `educ_high`. Here, `educ_high` plays the role of `female` in the first two parts of the previous question.

Finally, explore whether the effect differs depending on whether individuals have at least one child at assignment. Group only by "one child" variable, do not continue to condition on education.

### Answer

1. We will use the JC data to calculate the ATE for the porportion of weeks employed in the fourth
year after assignment, 'pworky4'. The code below returns the average values for treatement and control
as well as the ATE in a table. First, 'group_by' splits the data into groups based on the value of the assignment variable. Next, 'summarise' collapses each group into a single row by computing the average of pworky4 within each assignment group. The 'pivot_wider' step reshapes the data from a long format into a wide format, creating separate columns for each value of assignment (prefixed with "assignment_") and filling them with the corresponding group means. Finally, 'mutate' adds the ATE variable.

```{r}
JC |>
  group_by(assignment) |>
  summarise(
    mean_pworky4 = mean(pworky4, na.rm = TRUE),
    .groups = "drop"
  ) |>
  (\(df) pivot_wider(
    df,
    names_from = assignment,
    values_from = mean_pworky4,
    names_prefix = "assignment_"
  ))() |>
  mutate(
    ATE = assignment_1 - assignment_0
  )
```

The estimated ATE is 3.27, indicating that assignment to the treatment increased proportion of weeks employed in the fourth year after assignment by approximately three weeks on average,
relative to the control group.

2. Next, we extend the analysis by estimating the ATE conditional on education group
(using the 'educ_high' variable created above) to examine whether the impact of the treatment differs
based on education level. The logic is very similar to the part 1, but this time we are grouping by 'educ_high' and 'assignment'.

```{r}
JC |>
  group_by(educ_high, assignment) |>
  summarise(
    mean_pworky4 = mean(pworky4, na.rm = TRUE),
    .groups = "drop"
  ) |>
  (\(df) pivot_wider(
    df,
    names_from = assignment,
    values_from = mean_pworky4,
    names_prefix = "assignment_"
  ))() |>
  mutate(
    CATE = assignment_1 - assignment_0
  )

```

For individuals with 12 years of education or more ('educ_high' = 1), the treatment increases proportion of weeks employed in the fourth year after assignment by 3.35 weeks. For those with 12 years of education or less (educ_high = 0), the estimated effect is slightly smaller, at 2.91 weeks. These results suggest that the program has a slightly larger impact on employment for higher-
educated individuals, although the difference is relatively small (0.44 weeks).

3. Using 'haschild' ('haschild' = 1 indicates at least one child, 'haschild' = 0 indicates no children at assignment), we’ll explore the effect of the program conditional on whether individuals have at least one child at assignment.

```{r}
JC |>
  group_by(haschild, assignment) |>
  summarise(
    mean_pworky4 = mean(pworky4, na.rm = TRUE),
    .groups = "drop"
  ) |>
  (\(df) pivot_wider(
    df,
    names_from = assignment,
    values_from = mean_pworky4,
    names_prefix = "assignment_"
  ))() |>
  mutate(
    CATE = assignment_1 - assignment_0
  )
```

For individuals without children at assignment ('haschild' = 0), the estimated CATE is 2.76 weeks of employment in the fourth year, while for those with at least one child at assignment ('haschild' = 1), the effect is substantially larger at 5.76 weeks (for a difference of 3 weeks). These results indicate that the treatment has a stronger impact on employment for parents, suggesting that the program may be particularly beneficial for individuals with children.

{{< pagebreak >}}

## Boxplots

This exercise will be demonstrated in class.

You will practice using `ggplot` to create data visualizations. Learning to work with `ggplot` could be its own course. In this course, it will be sufficient to modify the code discussed in class. For a deeper dive, [start with these resources](https://ggplot2.tidyverse.org/#learning-ggplot2).

You will continue with the `JC` data. A useful data summary for our purpose is the [boxplot](https://openintro-ims.netlify.app/explore-numerical#sec-boxplots).

First, make a boxplot of `earny4`. Second, make a boxplot of log earnings for those with positive earnings. Third, split out each of the two boxplots by `assignment`.

### Answer
To code our boxplot we use 'ggplot'. Using 'ggplot' allows us to build the plot step by step using JC data. Withing our 'ggplot' bracket, we indicate that the y axis should show the category for earnings after the fourth year of the program. Following 'ggplot', we use 'geom_boxplot'. This tells R to put the JC data into a boxplot. In the last step of the code, we set the titles. We repeated this code skeleton for all of the following boxplots, changing the variables to either be in logs, sorted by assignment or both. In the second step, these changes are made by indicating under 'ggplot' to filter earny4>0, this ensures that only positive values are included, essential when taking a logarithim. To split out each of the boxplots by 'assignment', we type factor(assignment, ...) in the first line of 'ggplot' code.
```{r}
ggplot(JC, aes(y = earny4)) +
  geom_boxplot() +
  labs(
    y = "Weekly earnings in 4th year after assignment",
    title = "Distribution of fourth-year earnings"
  )
```

This boxplot shows the weekly earnings in the fourth year after assignment on the y-axis and In this boxplot we see a skew to the right. This indicates that most individuals earn relatively low wages. The high earning individuals appear to be outliers. This suggests that only some individuals benefit largely in the fourth year post Job Corps program which indicates that the treatment did not have the same effect across all participants. 

In this plot, the effect of earnings are skewed by the extreme high values. This is because in a chart using levels, the differences are absolute and are thus highly influenced by outliers. This motivates the use of log earnings in the following charts since taking the logs compresses the upper tail of the distribution allow for comparisons which reflect proportional differences in earnings rather than absolute differences. 

```{r}
ggplot(
  JC |> filter(earny4 > 0),
  aes(y = log(earny4))
) +
  geom_boxplot() +
  labs(
    y = "Log weekly earnings in 4th year",
    title = "Distribution of log fourth-year earnings (earny4 > 0)"
  )
```

The second boxplot shows the distribution of log earnings for those with positive earnings. In this plot, we see that the earnings are more centred. This indicates that once we restrict for positive earnings, measured on a log scale the upper tail one the distribution becomes compressed. There remain some lower outliers, indicating that some individuals continue to have low but positive earnings. Thus, even when separating for positive earnings, heterogeneity of the results remain suggesting that there are other characteristics that influence earnings in the period four years after the program. 

```{r}
ggplot(JC, aes(x = factor(assignment), y = earny4)) +
  geom_boxplot() +
  labs(
    x = "Assignment",
    y = "Weekly earnings in 4th year",
    title = "Fourth-year earnings by treatment assignment"
  )
```

The boxplot, shows the  weekly earnings in the fourth year after the treatment and is grouped by assignment on the x-axis. The y-axis shows the level of weekly earnings. In this plot, all earnings are positive. Dividing the earnings distribution by assignment highlights the differences in earnings between the control group (assignment = 0) and the treatment group (assignment = 1). We see a strong right-skew of earnings in both groups. This indicates that most individuals earn relatively low wages. We can note that there are few outliers in the control group with very high earnings. The outliers in both the treatment and the control group suggest that there may be heterogeneous program effects. However, it is important to distinguish that the treatment group has shows a higher median level of earnings. This suggests that there was a positive effect from the Jobs Corps program. 

```{r}
ggplot(
  JC |> filter(earny4 > 0),
  aes(x = factor(assignment), y = log(earny4))
) +
  geom_boxplot() +
  labs(
    x = "Assignment",
    y = "Log weekly earnings in 4th year",
    title = "Log fourth-year earnings by treatment assignment"
  )
```
This final boxplot shows the positive earnings by assignment. It compares the distribution of log weekly earnings in the fourth year after the assignment between the control group and the (assignment = 0) and the treatment group (assignment = 1). All individuals in this plot are restricted to have positive earnings. On the boxplot, we see that there is a higher median log earnings in the treatment group. This indicates that those assigned to the Jobs Corps training program have higher typical earnings four years after  the treatment assignment. This suggests a positive average treatment effect of Jobs Corps on earnings. 

There is substantial overlap between the distributions of the treatment and control group. This suggests that the programs effects were moderate and there may be other characteristics driving certain individuals to earn higher wages. 

...

{{< pagebreak >}}

## Scatterplots

You are going to use scatterplots to visualize the relationship between pre-program earnings, post-program earnings, and treatment assignment. This question will require you to figure out how `geom_point` works. Use the sources provided in the instructions.

First, create a scatterplot with average weekly gross earnings at assignment on the horizontal axis, and weekly earnings in fourth year after assignment on the vertical axis. Use only individuals that have positive earnings at both of those moments. Use log earnings in your plot. Hint: scatter plots use `geom_point` instead of `geom_boxplot`.

Second, add a least squares fit by using `geom_smooth`.

Third, split the results out by `assignment`, by setting `colour = assignment`. Interpret your findings.

### Answer

1. We will use 'ggplot' and 'geom_point' to create a scatterplot of logged earnings at assignment, 'mwearn' and at year 4, 'earny4'. The code filters the data to include only individuals with positive earnings at assignment and in year 4 so that taking logarithms is valid. It creates a scatterplot of log earnings at assignment versus log earnings in year 4, adds semi-transparent points, and overlays a dashed 45-degree reference line showing where earnings would be equal in both periods.

```{r}
library(ggplot2)

JC |>
  filter(mwearn > 0, earny4 > 0) |>  # keep only positive earnings
  ggplot(aes(x = log(mwearn), y = log(earny4))) +
  geom_point(alpha = 0.5) +          # semi-transparent points for clarity
  geom_abline(
    slope = 1,
    intercept = 0,
    linetype = "dashed",
    color = "red"
  ) +                                # 45-degree reference line
  labs(
    x = "Log Average Weekly Earnings at Assignment",
    y = "Log Weekly Earnings in Year 4",
    title = "Scatterplot of Log Earnings: Average Weekly Earnings at Assignment vs Year 4"
  ) +
  theme_minimal()

```

The scatterplot of log earnings at assignment versus log earnings in the fourth year shows that
most individuals are concentrated in the middle of the earnings distribution (between log earnings of 4 and 6 in year 4 and at assignment). There is only a slight upward-right trend, indicating a weak positive relationship between initial and later earnings. This suggests that while higher earnings at assignment are somewhat associated with higher earnings in year 4, there is substantial variation in earnings growth across individuals.

2. Next, we will use geom_smooth() to add a least-squares regression line to our scatterplot to
show the overall trend in log earnings. The code is similar to above, but overlays a least-squares regression line with a confidence band using geom_smooth(method = "lm").

```{r}
JC |>
  filter(mwearn > 0, earny4 > 0) |>
  ggplot(aes(x = log(mwearn), y = log(earny4))) +
  geom_point(alpha = 0.5) +                    # points
  geom_smooth(
    method = "lm",
    se = TRUE,
    color = "blue"
  ) +                                          # least-squares fit with confidence band
  labs(
    x = "Log Average Weekly Earnings at Assignment",
    y = "Log Weekly Earnings in Year 4",
    title = "Scatterplot of Log Earnings with Least-Squares Fit"
  ) +
  theme_minimal()

```

The scatterplot with a least-squares fit shows that earnings at assignment are only weakly predic-
tive of earnings in the fourth year. The slope of the regression line is slightly upward, indicating
that higher initial earnings are associated with slightly higher later earnings, but the relationship
is modest. Most individuals cluster near the middle of the distribution, and there is considerable
variation in earnings growth across individuals.

3. Lastly, we will add color by treatment group to see separate trends for treated and control
groups and their fitted lines. This is again similar to the code above, but adds colours to points by treatment group ('assignment') using 'factor' to treat assignment as a categorical variable rather than a numeric one. This ensures that each group gets a separate colour and that geom_smooth() draws separate regression lines with confidence bands for each group.

```{r}
JC |>
  filter(mwearn > 0, earny4 > 0) |>
  ggplot(aes(x = log(mwearn), y = log(earny4), color = factor(assignment))) +
  geom_point(alpha = 0.5) +                    # semi-transparent points
  geom_smooth(method = "lm", se = TRUE) +      # separate regression lines by color with confidence bands
  labs(
    x = "Log Average Weekly Earnings at Assignment",
    y = "Log Weekly Earnings in Year 4",
    color = "Assignment",
    title = "Scatterplot of Log Earnings by Treatment with Least-Squares Fit"
  ) +
  theme_minimal()

```

The control group’s line (denoted in orange) is relatively flat, suggesting that initial earnings have little effect on year-4 earnings for this group. In contrast, the treated group’s line (denoted in blue) is slightly steeper, indicating that higher initial earnings are associated with higher year-4 earnings, and that the treatment amplifies earnings growth. Overall, this suggests that the treatment has a slightly larger positive impact on earnings, particularly for individuals who started with higher earnings, while individual variation remains substantial.

{{< pagebreak >}}

# HIV information experiment

## Loading data

From the `causaldata` package, load the `thornton_hiv` data, and then turn it into a tibble after removing all missing data using `drop_na`. You can use `?thornton_hiv` to find the variable descriptions. This exercise is based on the replication in [The Mixtape, Chapter 4](https://mixtape.scunning.com/04-potential_outcomes).

You can read Chapter 4 as a secondary source about the material we discussed this week. Please read [Section 4.1.5](https://mixtape.scunning.com/04-potential_outcomes#4-1-5-sutva) before attempting this exercise, to read the necessary background about this experiment. Reading this section is also part of your self-study about SUTVA.

> Respondents in rural Malawi were offered a free door-to-door HIV test and randomly assigned no voucher or vouchers ranging from \$1–\$3. These vouchers were redeemable once they visited a nearby voluntary counseling and testing center (VCT).

In this data set, which variable corresponds to $D$? Which variable corresponds to $Y$?

First, use `group_by` and `summarize` to compute the group-specific means. Friendly reminder to use `drop_na()`! Second, repeat this exercise to compute a group-specific mean for each value of `tinc`. Third, take the resulting table and plot it using `geom_point` and/or `geom_line`. Interpret the results.

### Answer

```{r}
install.packages("causaldata")
# Packages
library(causaldata)
library(dplyr)
library(tidyr)
library(ggplot2)
library(tibble)

data("thornton_hiv")

thornton <- thornton_hiv |>
  drop_na() |>
  as_tibble()

thornton |>
  group_by(any) |>
  summarize(
    mean_got = mean(got),
    n = n(),
    .groups = "drop"
  )

by_amount <- thornton |>
  group_by(tinc) |>
  summarize(
    mean_got = mean(got),
    n = n(),
    .groups = "drop"
  )

by_amount

ggplot(by_amount, aes(x = tinc, y = mean_got)) +
  geom_point(size = 3) +
  geom_line() +
  labs(
    x = "Voucher amount (tinc, USD)",
    y = "Pr(got tested)",
    title = "HIV Testing Uptake by Incentive Amount"
  ) +
  theme_minimal()

```

...

{{< pagebreak >}}

## Treatment effects by age

You will now analyze the effect of `age` by adapting the approach we used for `educ`.

First, create a binarized variable, cutting off `age` at a value that you can determine. Second, compute the means for control and treatment group for each value of the binarized variable. Interpret your results.

### Answer

```{r}
median(JC$age, na.rm = TRUE)
```

To choose an age of the cutoff range, we use the sample median age. To determine this we ran the code above. The output is that the sample median age is 18. Thus, those in the older group are those aged 18 or older and those in the younger group are 17 and below. 


```{r}
age_cut <- median(JC$age, na.rm = TRUE)

JC <- JC |>
  mutate(age_high = age >= age_cut)
JC |> 
  count(age_high)
```

This splits the sample into a "younger" and "older" group. In the younger group, we have 3740 observations and 5500 observations in the older group. Age_higher = FALSE indicates the younger age group. 

```{r}
JC |>
  filter(educmis == 0) |>
  group_by(age_high, assignment) |>
  summarize(EY = mean(earny4), .groups = "drop") |>
  pivot_wider(names_from = assignment,
              values_from = EY,
              names_prefix = "assign_") |>
  mutate(CATE = assign_1 - assign_0)
```

To compute the means for the control and treatment group for each value of the binarized variable we ran the code above. The CATE is the conditional average treatment effect and shows the different in mean earnings between the treatment and control.  

Our results show that the CATE for younger individuals is 10.7. This means that assignment to Jobs Corps increases fourth-year earnings by about 10.7 units for younger individuals. The control mean for younger individuals is 177 and the treatment mean is 188. 

For older individuals (age_high = TRUE), the control mean is 214 and the treatment mean is 231. The CATE is 17. Thus, our findings suggest that the increased average earnings is higher for older individuals. This suggests heterogeneous treatment effects by age.  

{{< pagebreak >}}

# For troubleshooting: do not edit or remove

```{r}
#| echo: false
Sys.info()
Sys.time()
```